<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leni's Pickleball Tournament Generator</title>
    <style>
        /* Keep all your original CSS */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        .round {
            margin-bottom: 30px;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid #4ECDC4;
            /* Prevent page breaks inside rounds when printing */
            page-break-inside: avoid;
            break-inside: avoid;
        }
        .round h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 1.3em;
        }
        .courts {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .court {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #e9ecef;
            transition: all 0.3s ease;
        }
        .court:hover {
            border-color: #4ECDC4;
            transform: translateY(-2px);
        }
        .court-title {
            font-weight: bold;
            color: #495057;
            margin-bottom: 8px;
            text-align: center;
        }
        .team {
            margin: 5px 0;
            padding: 5px 10px;
            background: #e3f2fd;
            border-radius: 15px;
            font-size: 14px;
        }
        .team1 { 
            background: linear-gradient(45deg, #FFE0B2, #FFCC80); 
            text-align: center;
        }
        .team2 { 
            background: linear-gradient(45deg, #E1F5FE, #B3E5FC); 
            text-align: center;
        }
        .vs-text {
            text-align: center;
            margin: 5px 0;
            font-weight: bold;
        }
        .sitting-out {
            background: #fff3e0;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid #FF9800;
        }
        .stats {
            margin-top: 30px;
            background: #e8f5e8;
            padding: 20px;
            border-radius: 10px;
             /* Force a page break before the stats section when printing */
            page-break-before: always;
            break-before: always;
        }
        .stats h3 {
            color: #2e7d32;
            margin-bottom: 15px;
        }
        .player-stats {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 10px;
            font-size: 14px;
        }
        .info-box {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #2196F3;
        }
        /* Generating overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.4);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        .modal-box {
            background: white;
            padding: 20px 28px;
            border-radius: 10px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.3);
            display: flex;
            gap: 12px;
            align-items: center;
            font-weight: 600;
            color: #333;
        }
        .spinner {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 4px solid #e0e0e0;
            border-top-color: #4ECDC4;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        /* Add print-specific styles */
        @media print {
            body {
                background: none;
                padding: 0;
                margin: 0;
            }
            .container {
                box-shadow: none;
                padding: 15px;
            }
            .court:hover {
                transform: none;
            }
            /* Further reduce margins and padding for print */
            .round {
                margin-bottom: 15px;
                padding: 10px;
            }
            /* Force background colors to print */
            * {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèì Leni's Round Robin Pickleball Tournament</h1>
        
        <div class="info-box">
            <strong>Tournament Setup</strong>
            <div style="margin-top:8px;">
                <label for="playerNames"><strong>Player names</strong> (one per line or comma separated)</label><br>
                <textarea id="playerNames" rows="8" style="width:100%; margin-top:8px;"></textarea>
            </div>
            <div style="display:flex; gap:12px; margin-top:12px; flex-wrap:wrap; align-items:center;">
                <label>Courts: <input id="numCourts" type="number" min="1" value="5" style="width:80px; margin-left:6px;"></label>
                <label>Rounds: <input id="numRounds" type="number" min="1" value="11" style="width:80px; margin-left:6px;"></label>
                <button id="generateBtn" style="padding:8px 12px; border-radius:6px; border:none; background:#4ECDC4; color:#fff; cursor:pointer;">Generate</button>
                <button id="exportBtn" style="padding:8px 12px; border-radius:6px; border:none; background:#2196F3; color:#fff; cursor:pointer;">Export</button>
            </div>
            <div id="setupSummary" style="margin-top:10px; color:#555; font-size:0.95em;"></div>
        </div>

        <div id="tournament"></div>
        <div id="stats"></div>
        <!-- Generating overlay -->
        <div id="generatingModal" class="modal-overlay" aria-hidden="true">
            <div class="modal-box" role="status" aria-live="polite">
                <div class="spinner" aria-hidden="true"></div>
                <div>Generating schedule ‚Äî please wait...</div>
            </div>
        </div>
    <script>
        // Configurable globals
        let players = [];
        let tournament = [];
        let numCourts = 5;
        let numRounds = 11;

        // Default players to prefill the textarea
        const defaultPlayers = [
            "Jen","Carol","Nancy","Linda","Qi","Gina","Leni","Wei","Jeanette",
            "Connie","Lisa","Megan","Teresa","Heidi","Jane","Patty","Julie","Marla",
            "Mary Beth","Mary L","Melissa","Elissa"
        ];

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function getPlayersFromInput() {
            const raw = document.getElementById('playerNames').value;
            // Split by newline or comma
            const parts = raw.split(/\r?\n|,/).map(s => s.trim()).filter(Boolean);
            return parts;
        }

        function updateSetupSummary() {
            const summary = document.getElementById('setupSummary');
            const playersList = getPlayersFromInput();
            const playersCount = playersList.length;
            const playersPerRound = numCourts * 4;
            const sitOut = playersCount - playersPerRound;
            summary.innerHTML = `${playersCount} players, ${numCourts} courts (${playersPerRound} players/round), ${numRounds} rounds.` +
                (sitOut > 0 ? ` Sit out per round: ${sitOut}` : sitOut === 0 ? ` No one sits out` : ` Not enough players for ${numCourts} courts`);
        }

        function generateTournament() {
            players = getPlayersFromInput();
            numCourts = parseInt(document.getElementById('numCourts').value, 10) || 1;
            numRounds = parseInt(document.getElementById('numRounds').value, 10) || 1;

            const playersPerRound = numCourts * 4;
            const sitOutCount = players.length - playersPerRound;
            if (sitOutCount < 0) {
                alert(`Not enough players for ${numCourts} courts. Need at least ${playersPerRound} players.`);
                return;
            }

            tournament = [];

            // Tracking
            const teamPartnerships = new Map();
            const courtCount = new Map();
            const sittingOutCount = new Map();

            players.forEach(p => {
                teamPartnerships.set(p, new Set());
                courtCount.set(p, 0);
                sittingOutCount.set(p, 0);
            });

            for (let round = 1; round <= numRounds; round++) {
                const roundData = generateRound(round, teamPartnerships, courtCount, sittingOutCount, sitOutCount);
                if (!roundData) {
                    console.warn('Failed to create round', round);
                    continue;
                }
                tournament.push(roundData);

                roundData.courts.forEach(court => {
                    // track partnerships
                    teamPartnerships.get(court.team1[0]).add(court.team1[1]);
                    teamPartnerships.get(court.team1[1]).add(court.team1[0]);
                    teamPartnerships.get(court.team2[0]).add(court.team2[1]);
                    teamPartnerships.get(court.team2[1]).add(court.team2[0]);

                    court.team1.forEach(p => courtCount.set(p, courtCount.get(p) + 1));
                    court.team2.forEach(p => courtCount.set(p, courtCount.get(p) + 1));
                });

                roundData.sittingOut.forEach(p => sittingOutCount.set(p, sittingOutCount.get(p) + 1));
            }

            displayTournament();
            displayStats(teamPartnerships, courtCount, sittingOutCount);
            updateSetupSummary();
        }

        function generateRound(roundNum, teamPartnerships, courtCount, sittingOutCount, sitOutCount) {
            let bestRound = null;
            let bestScore = -Infinity;
            const maxAttempts = 4000;

            // Prepare list of players sorted by how often they've sat out (asc)
            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                // choose sitting out players (prioritize those who've sat out least)
                const candidates = [...players].sort((a, b) => sittingOutCount.get(a) - sittingOutCount.get(b));
                // add some randomness among top candidates
                const pickPool = candidates.slice(0, Math.min(candidates.length, sitOutCount + 6));
                const shuffledPool = shuffleArray(pickPool);
                const sittingOut = shuffledPool.slice(0, sitOutCount);

                const playingPlayers = players.filter(p => !sittingOut.includes(p));
                const roundData = tryCreateRoundWithImprovedPartners(roundNum, playingPlayers, sittingOut, teamPartnerships);
                if (!roundData) continue;

                const score = evaluateRound(roundData, teamPartnerships, courtCount);
                if (score > bestScore) {
                    bestScore = score;
                    bestRound = roundData;
                }
            }

            if (!bestRound) {
                console.warn(`Could not create round ${roundNum} with constraints; using fallback.`);
                return createFallbackRound(roundNum, teamPartnerships, courtCount, sittingOutCount, sitOutCount);
            }

            return bestRound;
        }

        function tryCreateRoundWithImprovedPartners(roundNum, playingPlayers, sittingOut, teamPartnerships) {
            // Build interaction counts across previous rounds
            const playerInteractions = new Map();
            players.forEach(p => {
                playerInteractions.set(p, new Map());
                players.forEach(o => { if (p !== o) playerInteractions.get(p).set(o, 0); });
            });

            tournament.forEach(r => r.courts.forEach(court => {
                const courtPlayers = [...court.team1, ...court.team2];
                for (let i = 0; i < courtPlayers.length; i++) {
                    for (let j = i + 1; j < courtPlayers.length; j++) {
                        const p1 = courtPlayers[i], p2 = courtPlayers[j];
                        playerInteractions.get(p1).set(p2, playerInteractions.get(p1).get(p2) + 1);
                        playerInteractions.get(p2).set(p1, playerInteractions.get(p2).get(p1) + 1);
                    }
                }
            }));

            const possiblePairs = [];
            for (let i = 0; i < playingPlayers.length; i++) {
                for (let j = i + 1; j < playingPlayers.length; j++) {
                    const a = playingPlayers[i], b = playingPlayers[j];
                    let pairScore = 0;
                    if (teamPartnerships.get(a).has(b)) pairScore += 1000;
                    const interactionCount = playerInteractions.get(a).get(b) || 0;
                    pairScore += interactionCount * 100;
                    const indexDiff = Math.abs(players.indexOf(a) - players.indexOf(b));
                    pairScore -= indexDiff * 5;
                    possiblePairs.push({ players: [a, b], score: pairScore });
                }
            }

            possiblePairs.sort((x, y) => x.score - y.score);

            const teamsNeeded = playingPlayers.length / 2; // two players per team

            for (let attempt = 0; attempt < 100; attempt++) {
                const availablePairs = [...possiblePairs];
                const topSlice = Math.min(availablePairs.length, teamsNeeded * 3);
                const topPairs = availablePairs.slice(0, topSlice);
                const shuffledTop = shuffleArray(topPairs);
                availablePairs.splice(0, topSlice, ...shuffledTop);

                const teams = [];
                const used = new Set();
                for (let i = 0; i < availablePairs.length && teams.length < teamsNeeded; i++) {
                    const [p1, p2] = availablePairs[i].players;
                    if (used.has(p1) || used.has(p2)) continue;
                    teams.push([p1, p2]);
                    used.add(p1); used.add(p2);
                }

                if (teams.length < teamsNeeded) continue;

                const courts = createCourtsWithMinimizedInteractions(teams, playerInteractions);
                return { round: roundNum, courts, sittingOut };
            }

            return null;
        }

        function createCourtsWithMinimizedInteractions(teams, playerInteractions) {
            let bestCourts = null;
            let bestScore = Infinity;
            for (let attempt = 0; attempt < 200; attempt++) {
                const shuffled = shuffleArray([...teams]);
                const courts = [];
                let score = 0;
                for (let i = 0; i < numCourts; i++) {
                    const t1 = shuffled[i * 2];
                    const t2 = shuffled[i * 2 + 1];
                    t1.forEach(p1 => t2.forEach(p2 => { score += playerInteractions.get(p1).get(p2) || 0; }));
                    courts.push({ number: i + 1, team1: t1, team2: t2 });
                }
                if (score < bestScore) { bestScore = score; bestCourts = courts; }
            }
            return bestCourts;
        }

        function createFallbackRound(roundNum, teamPartnerships, courtCount, sittingOutCount, sitOutCount) {
            // More relaxed fallback that still tries to minimize duplicates
            const playerInteractions = new Map();
            players.forEach(p => { playerInteractions.set(p, new Map()); players.forEach(o => { if (p !== o) playerInteractions.get(p).set(o, 0); }); });
            tournament.forEach(r => r.courts.forEach(court => {
                const courtPlayers = [...court.team1, ...court.team2];
                for (let i = 0; i < courtPlayers.length; i++) {
                    for (let j = i + 1; j < courtPlayers.length; j++) {
                        const p1 = courtPlayers[i], p2 = courtPlayers[j];
                        playerInteractions.get(p1).set(p2, playerInteractions.get(p1).get(p2) + 1);
                        playerInteractions.get(p2).set(p1, playerInteractions.get(p2).get(p1) + 1);
                    }
                }
            }));

            let bestRound = null;
            let bestDuplicates = Infinity;
            let bestScore = -Infinity;

            for (let attempt = 0; attempt < 3000; attempt++) {
                const playersArray = shuffleArray([...players]);
                const candidates = playersArray.sort((a, b) => sittingOutCount.get(a) - sittingOutCount.get(b));
                const sittingOut = candidates.slice(0, sitOutCount);
                const playing = playersArray.filter(p => !sittingOut.includes(p));

                const possiblePairs = [];
                for (let i = 0; i < playing.length; i++) {
                    for (let j = i + 1; j < playing.length; j++) {
                        const a = playing[i], b = playing[j];
                        let score = 0;
                        if (teamPartnerships.get(a).has(b)) score += 500;
                        const indexDiff = Math.abs(players.indexOf(a) - players.indexOf(b));
                        score -= indexDiff * 3;
                        possiblePairs.push({ players: [a, b], score });
                    }
                }
                possiblePairs.sort((x, y) => x.score - y.score);

                const teamsNeeded = playing.length / 2;
                const availablePairs = [...possiblePairs];
                const topSlice = Math.min(availablePairs.length, teamsNeeded * 3);
                const shuffledTop = shuffleArray(availablePairs.slice(0, topSlice));
                availablePairs.splice(0, topSlice, ...shuffledTop);

                const teams = [];
                const used = new Set();
                for (let i = 0; i < availablePairs.length && teams.length < teamsNeeded; i++) {
                    const [p1, p2] = availablePairs[i].players;
                    if (used.has(p1) || used.has(p2)) continue;
                    teams.push([p1, p2]); used.add(p1); used.add(p2);
                }
                if (teams.length < teamsNeeded) continue;

                const courts = createCourtsWithMinimizedInteractions(teams, playerInteractions);
                const roundData = { round: roundNum, courts, sittingOut };

                let duplicates = 0;
                teams.forEach(t => { if (teamPartnerships.get(t[0]).has(t[1])) duplicates++; });
                const score = evaluateRound(roundData, teamPartnerships, courtCount);
                if (duplicates < bestDuplicates || (duplicates === bestDuplicates && score > bestScore)) {
                    bestDuplicates = duplicates; bestScore = score; bestRound = roundData;
                    if (duplicates === 0) break;
                }
            }

            return bestRound;
        }

        function evaluateRound(roundData, teamPartnerships, courtCount) {
            let score = 0;
            roundData.courts.forEach(court => {
                if (teamPartnerships.get(court.team1[0]).has(court.team1[1])) score -= 1000;
                if (teamPartnerships.get(court.team2[0]).has(court.team2[1])) score -= 1000;
                const team1Diff = Math.abs(players.indexOf(court.team1[0]) - players.indexOf(court.team1[1]));
                const team2Diff = Math.abs(players.indexOf(court.team2[0]) - players.indexOf(court.team2[1]));
                score += (team1Diff + team2Diff) * 2;
            });
            const courtTimes = [];
            roundData.courts.forEach(court => { court.team1.forEach(p => courtTimes.push(courtCount.get(p))); court.team2.forEach(p => courtTimes.push(courtCount.get(p))); });
            if (courtTimes.length) {
                const maxTime = Math.max(...courtTimes); const minTime = Math.min(...courtTimes);
                score -= (maxTime - minTime) * 10;
            }
            return score;
        }

        function displayTournament() {
            const tournamentDiv = document.getElementById('tournament');
            let html = '';
            tournament.forEach(roundData => {
                html += `<div class="round"><h3>Round ${roundData.round}</h3><div class="courts">`;
                roundData.courts.forEach(court => {
                    html += `<div class="court"><div class="court-title">Court ${court.number}</div><div class="team team1">${court.team1.join(' & ')}</div><div class="vs-text">vs</div><div class="team team2">${court.team2.join(' & ')}</div></div>`;
                });
                html += `</div><div class="sitting-out"><strong>Sitting Out:</strong> ${roundData.sittingOut.join(', ')}</div></div>`;
            });
            tournamentDiv.innerHTML = html;
        }

        function displayStats(teamPartnerships, courtCount, sittingOutCount) {
            const statsDiv = document.getElementById('stats');
            // Count duplicate partnerships
            let duplicateCount = 0;
            teamPartnerships.forEach((partners, player) => {
                const duplicates = [...partners].filter(partner => player < partner && teamPartnerships.get(partner).has(player) && countPartnerships(player, partner) > 1);
                duplicateCount += duplicates.length;
            });

            const playerInteractions = new Map();
            players.forEach(p => { playerInteractions.set(p, new Map()); players.forEach(o => { if (p !== o) playerInteractions.get(p).set(o, 0); }); });
            tournament.forEach(roundData => roundData.courts.forEach(court => {
                const courtPlayers = [...court.team1, ...court.team2];
                for (let i = 0; i < courtPlayers.length; i++) for (let j = i + 1; j < courtPlayers.length; j++) {
                    const p1 = courtPlayers[i], p2 = courtPlayers[j];
                    playerInteractions.get(p1).set(p2, playerInteractions.get(p1).get(p2) + 1);
                    playerInteractions.get(p2).set(p1, playerInteractions.get(p2).get(p1) + 1);
                }
            }));

            let totalInteractions = 0; let pairCount = 0;
            playerInteractions.forEach((m, p) => m.forEach((c, q) => { if (p < q) { totalInteractions += c; pairCount++; } }));
            const avgInteractions = pairCount ? (totalInteractions / pairCount) : 0;

            let maxInteractions = 0; let maxPair = ['', ''];
            playerInteractions.forEach((m, p) => m.forEach((c, q) => { if (c > maxInteractions) { maxInteractions = c; maxPair = [p, q]; } }));

            const playerPartners = new Map(); players.forEach(p => playerPartners.set(p, [...teamPartnerships.get(p)].sort()));

            let html = `<div class="stats"><h3>Tournament Statistics</h3><p><strong>${duplicateCount}</strong> duplicate partnership${duplicateCount !== 1 ? 's' : ''} in the tournament.</p><p>Average player interactions: <strong>${avgInteractions.toFixed(2)}</strong></p><p>Maximum interactions: <strong>${maxInteractions}</strong> between ${maxPair[0]} & ${maxPair[1]}</p><div class="player-stats">`;

            players.forEach(player => {
                const partners = playerPartners.get(player);
                const partnerInfo = partners.map(partner => { const count = countPartnerships(player, partner); return count > 1 ? `${partner} (${count}√ó)` : partner; }).join(', ');
                const interactions = [...playerInteractions.get(player).entries()].sort((a, b) => b[1] - a[1]);
                const topInteractions = interactions.slice(0, 3).filter(([_, c]) => c > 0).map(([p, c]) => `${p} (${c}√ó)`).join(', ');
                html += `<div><strong>${player}:</strong><br>Games: ${courtCount.get(player)}, Sat out: ${sittingOutCount.get(player)}<br>Partnered with: ${partnerInfo}<br>Most played with: ${topInteractions}</div>`;
            });

            html += `</div></div>`;
            statsDiv.innerHTML = html;
        }

        function countPartnerships(player1, player2) {
            let count = 0;
            tournament.forEach(roundData => roundData.courts.forEach(court => {
                if ((court.team1[0] === player1 && court.team1[1] === player2) || (court.team1[0] === player2 && court.team1[1] === player1)) count++;
                if ((court.team2[0] === player1 && court.team2[1] === player2) || (court.team2[0] === player2 && court.team2[1] === player1)) count++;
            }));
            return count;
        }

        function exportTournament() {
            let exportText = "PICKLEBALL TOURNAMENT SCHEDULE\n============================\n\n";
            tournament.forEach(roundData => {
                exportText += `ROUND ${roundData.round}\n` + "-".repeat(20) + "\n";
                roundData.courts.forEach(court => { exportText += `Court ${court.number}: ${court.team1.join(' & ')} vs ${court.team2.join(' & ')}\n`; });
                exportText += `Sitting Out: ${roundData.sittingOut.join(', ')}\n\n`;
            });
            const blob = new Blob([exportText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'pickleball_tournament.txt'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        }

        

        // Helper to show/hide generating overlay
        function showGenerating(show) {
            const modal = document.getElementById('generatingModal');
            if (show) {
                modal.style.display = 'flex';
                modal.setAttribute('aria-hidden', 'false');
            } else {
                modal.style.display = 'none';
                modal.setAttribute('aria-hidden', 'true');
            }
        }

        // Wire UI
        document.getElementById('generateBtn').addEventListener('click', () => {
            // Show overlay, then wait two animation frames so the browser has a chance to paint
            showGenerating(true);
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    try {
                        generateTournament();
                    } finally {
                        showGenerating(false);
                    }
                });
            });
        });

        document.getElementById('exportBtn').addEventListener('click', () => exportTournament());
        document.getElementById('numCourts').addEventListener('change', (e) => { numCourts = parseInt(e.target.value, 10) || 1; updateSetupSummary(); });
        document.getElementById('numRounds').addEventListener('change', (e) => { numRounds = parseInt(e.target.value, 10) || 1; updateSetupSummary(); });
        document.getElementById('playerNames').addEventListener('input', updateSetupSummary);

        // Prefill and initial render
        document.getElementById('playerNames').value = defaultPlayers.join('\n');
        updateSetupSummary();
        // Generate initial tournament on load (show overlay while building) and ensure overlay paints first
        showGenerating(true);
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                try { generateTournament(); } finally { showGenerating(false); }
            });
        });
    </script>
</body>
</html>